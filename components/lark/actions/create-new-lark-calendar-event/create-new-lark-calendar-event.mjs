import { ConfigurationError } from "@pipedream/platform";
import {
  ATTENDEE_ABILITY_OPTIONS,
  FREE_BUSY_STATUS_OPTIONS,
  ICON_TYPE_OPTIONS,
  VC_TYPE_OPTIONS,
  VISIBILITY_OPTIONS,
} from "../../common/constants.mjs";
import lark from "../../lark.app.mjs";

export default {
  key: "lark-create-new-lark-calendar-event",
  name: "Create New Lark Calendar Event",
  description: "Creates a new event in Lark's calendar. [See the documentation](https://open.larksuite.com/document/server-docs/calendar-v4/calendar-event/create)",
  version: "0.0.1",
  type: "action",
  props: {
    lark,
    calendarId: {
      propDefinition: [
        lark,
        "calendarId",
      ],
    },
    summary: {
      type: "string",
      label: "Summary",
      description: "Event title.",
    },
    description: {
      type: "string",
      label: "Description",
      description: "Event description. Supports parsing HTML tags. **Note:** While HTML tags can be used to achieve some rich text formatting, the rich text formatting generated by the client is not implemented using HTML tags. If you update the description through the API after generating rich text formatting on the client side, it may result in the loss of the original rich text formatting applied by the client.",
      optional: true,
    },
    needNotification: {
      type: "boolean",
      label: "Need Notification",
      description: "Whether to send Bot notifications to event participants when updating the event.",
      optional: true,
    },
    startTimeDate: {
      type: "string",
      label: "Start Time Date",
      description: "Start time, only use this field for all-day events, [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format, for example, 2018-09-01.",
      optional: true,
    },
    startTimeTimestamp: {
      type: "string",
      label: "Start Time Timestamp",
      description: "Second-level timestamp, used to set a specific start time. For example, 1602504000 means 2020/10/12 20:00:00 (UTC +8 time zone).",
      optional: true,
    },
    startTimeTimezone: {
      type: "string",
      label: "Start Time Timezone",
      description: "Time zone. Use IANA Time Zone Database standards such as Asia/Shanghai.",
      optional: true,
    },
    endTimeDate: {
      type: "string",
      label: "End Time Date",
      description: "End time, only use this field for all-day events, [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format, for example, 2018-09-01.",
      optional: true,
    },
    endTimeTimestamp: {
      type: "string",
      label: "End Time Timestamp",
      description: "Second-level timestamp, used to set a specific end time. For example, 1602504000 means 2020/10/12 20:00:00 (UTC +8 time zone).",
      optional: true,
    },
    endTimeTimezone: {
      type: "string",
      label: "End Time Timezone",
      description: "Time zone. Use IANA Time Zone Database standards such as Asia/Shanghai.",
      optional: true,
    },
    vcType: {
      type: "string",
      label: "VC Type",
      description: "Video conferencing type. If video conferencing is not required, no_meeting must be passed. **Default value:** empty, which means the Lark video conference URL will be automatically generated when a event participant is added for the first time.",
      options: VC_TYPE_OPTIONS,
      optional: true,
    },
    iconType: {
      type: "string",
      label: "Icon Type",
      description: "The icon type of the video conferencing.",
      options: ICON_TYPE_OPTIONS,
      optional: true,
    },
    vchatDescription: {
      type: "string",
      label: "VChat Description",
      description: "Video conference copywriting.",
      optional: true,
    },
    meetingUrl: {
      type: "string",
      label: "Meeting URL",
      description: "Video conference URL.",
      optional: true,
    },
    visibility: {
      type: "string",
      label: "Visibility",
      description: "Event visibility. The value is Default for new events by default. This is valid for all invitees only when an event is created. Any changes to the property are valid only for the current identity.",
      options: VISIBILITY_OPTIONS,
      optional: true,
    },
    attendeeAbility: {
      type: "string",
      label: "Attendee Ability",
      description: "Event invitees' scopes.",
      options: ATTENDEE_ABILITY_OPTIONS,
      optional: true,
    },
    freeBusyStatus: {
      type: "string",
      label: "Free/Busy Status",
      description: "Event availability. The value is Busy for new events by default. This is valid for all invitees only when an event is created. Any changes to the property are valid only for the current identity.",
      options: FREE_BUSY_STATUS_OPTIONS,
      optional: true,
    },
    locationName: {
      type: "string",
      label: "Location Name",
      description: "Name of the location.",
      optional: true,
    },
    locationAddress: {
      type: "string",
      label: "Location Address",
      description: "Address of the location.",
      optional: true,
    },
    locationLatitude: {
      type: "string",
      label: "Location Latitude",
      description: "Latitude coordinate of the location. Locations within China Mainland should comply with the GCJ-02 standard, and locations outside China Mainland should comply with the WGS84 standard.",
      optional: true,
    },
    locationLongitude: {
      type: "string",
      label: "Location Longitude",
      description: "Longitude coordinate of the location. Locations within China Mainland should comply with the GCJ-02 standard, and locations outside China Mainland should comply with the WGS84 standard.",
      optional: true,
    },
    color: {
      type: "integer",
      label: "Color",
      description: "Event color, the value is represented by an int32 color RGB value.",
      optional: true,
    },
    recurrence: {
      type: "string",
      label: "Recurrence",
      description: "Recurrence rule for recurring events. For details, see [RFC 5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10). E.g. `FREQ=DAILY;INTERVAL=1`.",
      optional: true,
    },
  },
  async run({ $ }) {
    if (!this.startTimeDate && !this.startTimeTimestamp) {
      throw new ConfigurationError("You must provide at least one of `start time date` or `start time timestamp`");
    }
    if (this.startTimeDate && this.startTimeTimestamp) {
      throw new ConfigurationError("You must provide either `start time date` or `start time timestamp`, but not both");
    }
    if (!this.endTimeDate && !this.endTimeTimestamp) {
      throw new ConfigurationError("You must provide at least one of `end time date` or `end time timestamp`");
    }
    if (this.endTimeDate && this.endTimeTimestamp) {
      throw new ConfigurationError("You must provide either `end time date` or `end time timestamp`, but not both");
    }

    const response = await this.lark.createCalendarEvent({
      $,
      calendarId: this.calendarId,
      data: {
        summary: this.summary,
        description: this.description,
        need_notification: this.needNotification,
        start_time: {
          date: this.startTimeDate,
          timestamp: this.startTimeTimestamp,
          timezone: this.startTimeTimezone,
        },
        end_time: {
          date: this.endTimeDate,
          timestamp: this.endTimeTimestamp,
          timezone: this.endTimeTimezone,
        },
        vchat: {
          vc_type: this.vcType,
          icon_type: this.iconType,
          description: this.vchatDescription,
          meeting_url: this.meetingUrl,
        },
        visibility: this.visibility,
        attendee_ability: this.attendeeAbility,
        free_busy_status: this.freeBusyStatus,
        location: {
          name: this.locationName,
          address: this.locationAddress,
          latitude: this.locationLatitude
            ? parseFloat(this.locationLatitude)
            : undefined,
          longitude: this.locationLongitude
            ? parseFloat(this.locationLongitude)
            : undefined,
        },
        color: this.color,
        recurrence: this.recurrence,
      },
    });

    $.export("$summary", `Successfully created calendar event with ID: ${response.data.event.event_id}`);
    return response;
  },
};
