import  * as flpnodejs from 'fraudlabspro-nodejs';

export default {
  name: "Feedback Order",
  description: "Update status of a transaction from pending-manual-review to APPROVE, REJECT or IGNORE. The FraudLabs Pro algorithm will improve the formula in determine the FraudLabs Pro score using the data collected. Please refer to the [documentation](https://www.fraudlabspro.com/developer/api/feedback-order) for the explanation of the result returned.",
  key: "fraudlabs_pro-feedback-order",
  version: "0.0.1",
  type: "action",
  props: {
    flp_api_key: {
      type: "app",
      app: "fraudlabs_pro",
      description: "API license key. You can sign up for a trial key at [here](https://www.fraudlabspro.com/subscribe?id=1).",
    },
    id: {
      type: "string",
      label: "ID",
      description: "Unique transaction Id generated by Fraud Check API.",
    },
    format: {
      type: "string",
      label: "Result Format",
      description: "*(optional)* Format of the result. Available values are `json` or `xml`. If unspecified, json format will be used for the response message.",
      optional: true,
    },
    action: {
      type: "string",
      label: "action",
      description: "Perform APPROVE, REJECT, or REJECT_BLACKLIST action to transaction. Available values are: `APPORVE` which will approve a transaction, `REJECT` which will reject a transaction, and `REJECT_BLACKLIST` which will reject and blacklist the transaction. When a transaction was blacklisted, the information will be recorded into the system for future blacklist validation check.",
    },
    note: {
      type: "string",
      label: "note",
      description: "*(optional)* Notes for the feedback request.",
      optional: true,
    },
  },
  async run() {

    var flp = new flpnodejs.FraudValidation(this.flp_api_key.$auth.api_key);

    const result_format = (typeof this.format === "undefined") ? "json" :`${this.format}`;

    var params = {
      id: `${this.id}`,
      format: result_format,
      action: `${this.action}`,
      note: (typeof this.note === "undefined") ? "" :`${this.note}`,
    };

    const process1 = await new Promise((resolve, reject) => {
      flp.feedback(params, (err, data) => {
        if (err) {
          reject(err)  // calling `reject` will cause the promise to fail with or without the error passed as an argument
          return        // and we don't want to go any further
        }
        resolve(data)
      })})
      .then(data => {
      //console.log(data);
      return (data);
      })
      .catch(err => {console.error(err)});
    return process1;
  },
}